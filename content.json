[{"title":"小记Android客户端ByJian","date":"2016-12-13T08:15:35.000Z","path":"2016/12/13/小记Android客户端ByJian/","text":"down link：http://genng.github.io/html/smallnote/index_down.html","tags":[]},{"title":"移动H5前端性能优化指南","date":"2016-12-13T08:13:26.000Z","path":"2016/12/13/移动H5前端性能优化指南/","text":"概述 PC优化手段在Mobile侧同样适用 在Mobile侧我们提出三秒种渲染完成首屏指标 基于第二点，首屏加载3秒完成或使用Loading 基于联通3G网络平均338KB/s(2.71Mb/s)，所以首屏资源不应超过1014KB Mobile侧因手机配置原因，除加载外渲染速度也是优化重点 基于第五点，要合理处理代码减少渲染损耗 基于第二、第五点，所有影响首屏加载和渲染的代码应在处理逻辑中后置 加载完成后用户交互使用时也需注意性能 优化指南 [加载优化] 加载过程是最为耗时的过程，可能会占到总耗时的80%时间，因此是优化的重点 · 减少HTTP请求 因为手机浏览器同时响应请求为4个请求（Android支持4个，iOS 5后可支持6个），所以要尽量减少页面的请求数，首次加载同时请求数不能超过4个 a) 合并CSS、JavaScript b) 合并小图片，使用雪碧图 · 缓存 使用缓存可以减少向服务器的请求数，节省加载时间，所以所有静态资源都要在服务器端设置缓存，并且尽量使用长Cache（长Cache资源的更新可使用时间戳） a) 缓存一切可缓存的资源 b) 使用长Cache（使用时间戳更新Cache） c) 使用外联式引用CSS、JavaScript · 压缩HTML、CSS、JavaScript 减少资源大小可以加快网页显示速度，所以要对HTML、CSS、JavaScript等进行代码压缩，并在服务器端设置GZip a) 压缩（例如，多余的空格、换行符和缩进） b) 启用GZip · 无阻塞 写在HTML头部的JavaScript（无异步），和写在HTML标签中的Style会阻塞页面的渲染，因此CSS放在页面头部并使用Link方式引入，避免在HTML标签中写Style，JavaScript放在页面尾部或使用异步方式加载 · 使用首屏加载 首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏的快速显示做优化 · 按需加载 将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量 PS：按需加载会导致大量重绘，影响渲染性能 a) LazyLoad b) 滚屏加载 c) 通过Media Query加载 · 预加载 大型重资源页面（如游戏）可使用增加Loading的方法，资源加载完成后再显示页面。但Loading时间过长，会造成用户流失。 对用户行为分析，可以在当前页加载下一页资源，提升速度。 a) 可感知Loading(如进入空间游戏的Loading) b) 不可感知的Loading（如提前加载下一页） · 压缩图片 图片是最占流量的资源，因此尽量避免使用他，使用时选择最合适的格式（实现需求的前提下，以大小判断），合适的大小，然后使用智图压缩，同时在代码中用Srcset来按需显示 PS：过度压缩图片大小影响图片显示效果 a) 使用智图（ http://zhitu.tencent.com/ ） b) 使用其它方式代替图片(1. 使用CSS3 2. 使用SVG 3. 使用IconFont) c) 使用Srcset d) 选择合适的图片(1. webP优于JPG 2. PNG8优于GIF) e) 选择合适的大小（1. 首次加载不大于1014KB 2. 不宽于640（基于手机屏幕一般宽度）） · 减少Cookie Cookie会影响加载速度，所以静态资源域名不使用Cookie · 避免重定向 重定向会影响加载速度，所以在服务器正确设置避免重定向 · 异步加载第三方资源 第三方资源不可控会影响页面的加载和显示，因此要异步加载第三方资源 [脚本执行优化] 脚本处理不当会阻塞页面加载、渲染，因此在使用时需当注意 · CSS写在头部，JavaScript写在尾部或异步 · 避免图片和iFrame等的空Src 空Src会重新加载当前页面，影响速度和效率 · 尽量避免重设图片大小 重设图片大小是指在页面、CSS、JavaScript等中多次重置图片大小，多次重设图片大小会引发图片的多次重绘，影响性能 · 图片尽量避免使用DataURL DataURL图片没有使用图片的压缩算法文件会变大，并且要解码后再渲染，加载慢耗时长 [CSS优化] · 尽量避免写在HTML标签中写Style属性 · 避免CSS表达式 CSS表达式的执行需跳出CSS树的渲染，因此请避免CSS表达式 · 移除空的CSS规则 空的CSS规则增加了CSS文件的大小，且影响CSS树的执行，所以需移除空的CSS规则 · 正确使用Display的属性 Display属性会影响页面的渲染，因此请合理使用 a) display:inline后不应该再使用width、height、margin、padding以及float b) display:inline-block后不应该再使用float c) display:block后不应该再使用vertical-align d) display:table-*后不应该再使用margin或者float · 不滥用Float Float在渲染时计算量比较大，尽量减少使用 · 不滥用Web字体 Web字体需要下载，解析，重绘当前页面，尽量减少使用 · 不声明过多的Font-size 过多的Font-size引发CSS树的效率 · 值为0时不需要任何单位 为了浏览器的兼容性和性能，值为0时不要带单位 · 标准化各种浏览器前缀 a) 无前缀应放在最后 b) CSS动画只用 （-webkit- 无前缀）两种即可 c) 其它前缀为 -webkit- -moz- -ms- 无前缀 四种，（-o-Opera浏览器改用blink内核，所以淘汰） · 避免让选择符看起来像正则表达式 高级选择器执行耗时长且不易读懂，避免使用 [JavaScript执行优化] · 减少重绘和回流 a) 避免不必要的Dom操作 b) 尽量改变Class而不是Style，使用classList代替className c) 避免使用document.write d) 减少drawImage · 缓存Dom选择与计算 每次Dom选择都要计算，缓存他 · 缓存列表.length 每次.length都要计算，用一个变量保存这个值 · 尽量使用事件代理，避免批量绑定事件 · 尽量使用ID选择器 ID选择器是最快的 · TOUCH事件优化 使用touchstart、touchend代替click，因快影响速度快。但应注意Touch响应过快，易引发误操作 [渲染优化] · HTML使用Viewport Viewport可以加速页面的渲染，请使用以下代码 1· 减少Dom节点 Dom节点太多影响页面的渲染，应尽量减少Dom节点 · 动画优化 a) 尽量使用CSS3动画 b) 合理使用requestAnimationFrame动画代替setTimeout c) 适当使用Canvas动画 5个元素以内使用css动画，5个以上使用Canvas动画（iOS8可使用webGL） · 高频事件优化 Touchmove、Scroll 事件可导致多次渲染 a) 使用requestAnimationFrame监听帧变化，使得在正确的时间进行渲染 b) 增加响应变化的时间间隔，减少重绘次数 · GPU加速 CSS中以下属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）来触发GPU渲染，请合理使用 PS：过渡使用会引发手机过耗电增加","tags":[]},{"title":"新奥营业厅App接口 v1.0","date":"2016-12-13T08:12:43.000Z","path":"2016/12/13/新奥营业厅App接口-v1-0/","text":"###1、登录接口请求地址： account/dlu 请求参数：12name 用户名password 密码 请求方式： Http/Get 请求实例： http://xxx.xxx.xxx/account/dlu?name=xxx&amp;password=xxxx 返回值： 1234567错误的情况 &#123;&quot;success&quot;:false,&quot;message&quot;:&quot;密码错误&quot;,&quot;obj&quot;:4&#125; 参数说明： success 是否正确 message 提示信息 obj 错误代码 123456789101112131415正确的情况 &#123;&quot;success&quot;:true,&quot;message&quot;:&quot;登录成功&quot;,&quot;obj&quot;:&#123;&quot;smartid&quot;:&quot;5539e2431a1d6000fc29ec0d&quot;,&quot;name&quot;:&quot;1111111&quot;,&quot;nickname&quot;:&quot;小白&quot;,&quot;id&quot;:35056,&quot;jfflag&quot;:0,&quot;rzflag&quot;:1,&quot;zfpasswordflag&quot;:1,&quot;logontime&quot;:&quot;2014/9/12 15:35:52&quot;,&quot;rSAUsename&quot;:&quot;ACB73ACFF1DE62B302FB5B145D8CDDC5839D7AFD7C58D401B54A25E1D1E1D9DDE82DF08595C151C77DA04A3ABA517EFF3AA6E3285A69356B35C7045EC053D2EF55EA3C04A1DDCD3773A11CC8963484E8D02A17F3FC5BDC172AECDC09B25B3590592F9D2C0EBFB4313BF2C035B10402ABFFF888061E9E70A618AEEF81FAF8823B&quot;,&quot;from&quot;:&quot;3&quot;,&quot;pid&quot;:&quot;529&quot;&#125;&#125; 参数说明： smartid 唯一身份识别 70分钟失效 name 用户名 nickname 昵称 id 用户主键 jfflag 是否缴过费 默认 0 未缴过费 rzflag 是否实名认证 默认 0 未实名认证 zfpasswordflag 是否设置支付密码 默认 0 未设置 logontime 注册时间 rSAUsename RSA加密的用户名 适用于大米优惠活动 from 适用于大米优惠活动 pid 适用于大米优惠活动 ###2、注册接口（手机号）请求地址： Account/zcheMobile 请求参数：1234mobile 手机号password 密码phonecode 手机验证码agreeok 是否同意协议 1是同意 请求方式： Http/Get 请求实例： http://xxx.xxx.xxx/Account/zcheMobile?mobile=xxx&amp;password=xxxx&amp;&amp;phonecode=1235&amp;&amp;agreeok=1 返回值： 1234567错误的情况 &#123;&quot;success&quot;:false,&quot;message&quot;:&quot;手机号应该错误&quot;,&quot;obj&quot;:2&#125; 参数说明： success 是否正确 message 提示信息 obj 错误代码 12正确的情况 &#123;&quot;success&quot;:true,&quot;message&quot;:&quot;恭喜你，注册成功！&quot;,&quot;obj&quot;:3&#125; ###3、注册接口（邮箱）请求地址： Account/zcheEmail 请求参数：1234email 邮箱 password 密码validatecode 验证码agreeok 是否同意协议 1是同意 请求方式： Http/Get 请求实例： http://xxx.xxx.xxx/Account/zcheEmail?email=xxx&amp;password=xxxx&amp;&amp;validatecode=1235&amp;&amp;agreeok=1 返回值： 1234567错误的情况 &#123;&quot;success&quot;:false,&quot;message&quot;:&quot;手机号应该错误&quot;,&quot;obj&quot;:2&#125; 参数说明： success 是否正确 message 提示信息 obj 错误代码 12正确的情况 &#123;&quot;success&quot;:true,&quot;message&quot;:&quot;恭喜你，注册成功！&quot;,&quot;obj&quot;:3&#125; ###4、校验用户名是否存在 用于注册请求地址： Account/ValidateUserName 请求参数：1name 用户名 请求方式： Http/Get 请求实例： http://xxx.xxx.xxx/Account/ValidateUserName?name=xxx 返回值： 1234567错误的情况 &#123;&quot;success&quot;:false,&quot;message&quot;:&quot;手机号已经存在&quot;,&quot;obj&quot;:2&#125; 参数说明： success 是否正确 message 提示信息 obj 错误代码 12正确的情况 &#123;&quot;success&quot;:true,&quot;message&quot;:&quot;恭喜你，可以注册！&quot;,&quot;obj&quot;:3&#125; ###5、校验用户名 用于找回密码请求地址： Account/CheckName 请求参数：1name 用户名 请求方式： Http/Get 请求实例： http://xxx.xxx.xxx/Account/CheckName?name=xxx 返回值： 1234567891011错误的情况 &#123;&quot;success&quot;:false,&quot;message&quot;:&quot;用户名不存在&quot;,&quot;obj&quot;:0&#125; &#123;&quot;success&quot;:false,&quot;message&quot;:&quot;对不起，该用户没有验证手机&quot;,&quot;obj&quot;:1&#125; &#123;&quot;success&quot;:false,&quot;message&quot;:&quot;对不起，该用户没有验证手机,请通过验证邮箱修改密码&quot;,&quot;obj&quot;:2&#125; 参数说明： success 是否正确 message 提示信息 obj 错误代码 12正确的情况 &#123;&quot;success&quot;:true,&quot;message&quot;:&quot;&quot;,&quot;obj&quot;:&quot;xxxx&quot;&#125; ###6、校验手机验证码 用于找回密码请求地址： Account/ValidateCode 请求参数：12phone 手机号code 手机短信验证码 请求方式： Http/Get 请求实例： http://xxx.xxx.xxx/Account/ValidateCode?phone=xxx&amp;&amp;code=1234 返回值： 1234567错误的情况 &#123;&quot;success&quot;:false,&quot;message&quot;:&quot;验证码不正确&quot;,&quot;obj&quot;:0&#125; 参数说明： success 是否正确 message 提示信息 obj 错误代码 1234正确的情况 &#123;&quot;success&quot;:true,&quot;message&quot;:&quot;&quot;,&quot;obj&quot;:&quot;sidxxxxxx&quot;&#125; obj：用于修改密码的sid字段 ###7、修改密码 用于找回密码请求地址： Account/ChangePasswordNew 请求参数：1234phone 手机号SID 接口6返回的obj字段的数据newpassword 新密码 6-20位confirmnewpwd 确认密码 6-20位 请求方式： Http/Get 请求实例： http://xxx.xxx.xxx/Account/ChangePasswordNew?phone=xxx&amp;&amp;SID=1234&amp;&amp;newpassword=11&amp;confirmnewpwd=11 返回值： 1234567错误的情况 &#123;&quot;success&quot;:false,&quot;message&quot;:&quot;两次密码不一致&quot;,&quot;obj&quot;:0&#125; 参数说明： success 是否正确 message 提示信息 obj 错误代码 12正确的情况 &#123;&quot;success&quot;:true,&quot;message&quot;:&quot;修改成功！&quot;,&quot;obj&quot;:&quot;&quot;&#125; ###8、发送手机验证码请求地址： Account/CreateMobilePhoneCode 请求参数：12phone 手机号type（可选） 默认不传，当用于找回密码时，传值&quot;reset&quot; 请求方式： Http/Get 请求实例： http://xxx.xxx.xxx/Account/CreateMobilePhoneCode?phone=xxx 返回值： 1234567错误的情况 &#123;&quot;success&quot;:false,&quot;message&quot;:&quot;error&quot;,&quot;obj&quot;:0&#125; 参数说明： success 是否正确 message 提示信息 obj 错误代码 12345正确的情况 &#123;&quot;success&quot;:true,&quot;message&quot;:&quot;发送成功！&quot;,&quot;obj&quot;:&quot;xxxx&quot;&#125; 参数说明： obj为发送的验证码","tags":[]},{"title":"如何写面向互联网公司的求职简历","date":"2016-12-13T08:12:05.000Z","path":"2016/12/13/如何写面向互联网公司的求职简历/","text":"我在IT公司工作了六年，有着三年面试官的经历。在面试中，我发现很多人都不能写好一份求职简历，所以今天不谈iOS开发，谈谈如何写一份针对互联网公司的求职简历。 我主要想分享的内容包括： 简历的页数不要超过两页（最好一页） 删掉不必要的信息 如果你实在太牛逼，最多写2页 重要的信息写在最前面 你的联系方式 你最重要的工作经历 不要简单罗列工作经历 列出你的工作中有价值的细节（有哪些技术上的困难等） 不要写任何虚假或夸大的信息 类似精通java，精通C/C++等 不要附加任何可能带来负面印象的信息 不要加照片 不要写政治面貌 不要写奇怪的爱好（打游戏，喝酒，抽烟） 不要写参加过某某培训公司的iOS培训 尽量用专业邮箱 用PDF格式 ###简历不要超过两页（最好一页） 互联网公司和传统企业有着很大的区别，通常情况下，创新和效率是互联网公司比较追求的公司文化，所以体现在简历上，就是超过一页的简历通常会被认为不够专业。 更麻烦的是，多数这种简历很可能在HR手中就被过滤掉了，因为HR每天会收到大量的简历，一般情况下每份简历在手中的停留时间也就10秒钟左右。而超过一页的简历会需要更多的时间去寻找简历中的有价值部分，对于HR来说，她更倾向于认为这种人通常是不靠谱的，因为写个简历都不懂行规，为什么还要给他面试机会呢? 那么我们应该如何精简简历呢? 简单说来就是一个字：删！ 删掉不必要的自我介绍信息，很多求职者会将自己在学校所学的课程罗列上去，例如：C语言，数据结构，数学分析。。。好家伙，一写就是几十门，还放在简历的最上面，就怕面试官看不见。对于这类信息，一个字：删！面试官不Care你上了哪些课程，而且在全中国，大家上的课程也都大同小异，所以没必要写出来。 删除不必要的工作或实习、实践经历。如果你找一份程序员的工作，那么你参加了奥运会的志愿者活动，并且拿到了奖励或者你参加学校的辩论队，获得了最佳辩手这些经历通常是不相关的。诸如此类的还有你帮导师代课，讲了和工作不相关的某某专业课，或者你在学生会工作等等。删除不相关的工作、实习或实践内容可以保证你的简历干净。当然，如果你实在没得可写，比如你是应届生，一点实习经历都没有，那可以适当写一两条，保证你能写够一页的简历，但是那两条也要注意是强调你的团队合作能力或者执行力之类的技能，因为这些才是面试官感兴趣的。 删除不必要的证书：最多写个4、6级的证书，什么教师资格证，中高级程序员证，还有国内的各种什么认证，都是没有人Care的。 删除不必要的细节，作为iOS开发的面试官，很多求职者在介绍自己的iOS项目经历的时候，介绍了这个工程用的工作环境是Mac OS，使用的机器是Mac Mini，编译器是XCode4.x，能够运行在iOS4.3以上环境，还有一些人，把这个项目用到的开源库都写上啦，什么ASI, AFNetworking, Cocoapods啥的。这些其实都不是重点，请删掉。后面我会讲，你应该如何介绍你的iOS项目经历。 自我评价，这个部分是应届生最喜欢写的，各种有没有的优点都写上，例如： 性格开朗、稳重、有活力，待人热情、真诚；工作认真负责，积极主动，能吃苦耐劳，用于承受压力，勇于创新；有很强的组织能力和团队协作精神，具有较强的适应能力；纪律性强，工作积极配合；意志坚强，具有较强的无私奉献精神。对待工作认真负责，善于沟通、协调有较强的组织能力与团队精神；活泼开朗、乐观上进、有爱心并善于施教并行；上进心强、勤于学习能不断提高自身的能力与综合素质。 这些内容在面试的时候不太好考查，都可以删掉。通常如果有HR面的话，HR自然会考查一些你的沟通，抗压，性格等软实力。 我相信，不管你是刚毕业的学生，还是工作十年的老手，你都可以把你的简历精简到一页A4纸上。 ###重要的信息写在最前面 将你觉得最吸引人的地方写在最前面。如果你有牛逼公司的实习，那就把实习经历写在最前面，如果你在一个牛逼的实验室里面做科研，就把研究成果和论文写出来，如果你有获得过比较牛逼的比赛名次（例如google code, ACM比赛之类），写上绝对吸引眼球。 所以，每个人的简历的介绍顺序应该都是不一样的，不要在网上下载一个模板，然后就一项一项地填：教育经历，实习经历，得奖经历，个人爱好，这样的简历毫无吸引力，也无法突出你的特点。 除了你的个人特点是重要信息外，你的手机号，邮箱，毕业院校，专业以及毕业时间这些也都是非常重要的，一定要写在简历最上面。 ###不要简单地罗列工作经历 不要简单地说你开发了某某iOS客户端。这样简单的罗列你的作品集并不能让面试官很好地了解你的能力，当然，真正在面试时面试官可能会仔细询问，但是一份好的简历，应该省去一些面试官额外询问你的工作细节的时间。 具体的做法是：详细的描述你对于某某iOS客户端的贡献。主要包括：你参与了多少比例功能的开发? 你解决了哪些开发中的有挑战的问题? 你是不是技术负责人? 而且，通过你反思这些贡献，你也可以达到自我审视，如果你发现这个项目你根本什么有价值的贡献都没做，就打了打酱油，那你最好不要写在简历上，否则当面试官在面试时问起时，你会很难回答，最终让他发现你的这个项目经历根本一文不值时，肯定会给一个负面的印象。 ###不要写任何虚假或夸大的信息 刚刚毕业的学生都喜欢写精通Java，精通C/C++，其实代码可能写了不到1万行，我觉得你要精通某个语言，至少得写50万行这个语言的代码才行，而且要对语言的各种内部机制和原理有了解。那些宣称精通Java的同学，连Java如何做内存回收，如何做范型支持，如何做自动boxing和unboxing的都不知道，真不知道为什么要写精通2字。 任何夸大或虚假的信息，在面试时被发现，会造成极差的面试印象，所以你如果对某个知识一知半解，要么就写“使用过”某某，要么就干脆不写。如果你简历实在太单薄，没办法写上了一些自己打酱油的项目，被问起来怎么办? 请看看下面的故事： 我面试过一个同学，他的面试时非常诚实，问他一些简历上的东西，他如果不会，就会老实说，这个我只是使用了一下，确实不清楚细节。对于一些没有技术含量的项目，他也会老实说，这个项目他做的工作比较少，主要是别人在做。最后他还会补充说，“我自认为自己数据结构和算法还不错，要不你问我这方面的知识吧。” 这倒是一个不错的办法，对于一个没有项目经验，但是聪明并且数据结构和算法基础知识扎实的应届生，其实我们是非常愿意培养的。很多人以为公司面试是看经验，希望招进来就能干活，其实不是的，至少我们现在以及我以前在网易招人，面试的是对方的潜力，没有项目经验根本关系不大。 总之，不要写任何虚假或夸大的信息，即使你最终骗得过面试官，进了某公司，如果能力不够，在最初的试用期内，也很可能因为能力不足而被开掉。 ###不要附加任何可能带来负面印象的信息 任何与招聘工作无关的东西，尽量不要提。有些信息提了可能有加分，也可能有减分，取决于具体的面试官。而有些信息大部分情况下都是减分的，我罗列一下我认为是减分的信息。 不要在简历中附加个人照片。个人长相属于与工作能力不相关的信息，也许你觉得你长得很帅，那你怎么知道你的样子不和面试官的情敌长得一样? 也许你长得很漂亮，那么你怎么知道HR是否被你长得一样的小三把男朋友抢了? 我说得有点极端，那人们对于长相的评价标准确实千差万别，萝卜青菜各有所爱，加上可能有一些潜在的极端情况，所以没必要附加这部分信息。这属于加了可能有加分，也可能有减分的情况。 不要写你的政治面貌。你以为现在互联网公司还看重你是否是D员吗? 就算看重，你怎么知道他们认为这是加分还是减分? 我知道有一家公司，只要是D员的都直接拒掉。所以，除非你是面试的国企，在互联网公司，这一条最好不要写，写了有可能是平分，也有可能是减分，加分的可能性极小。 不要写各种奇怪的爱好。喜欢打Dota，喝酒，这类可能带来负面印象的爱好最好不要写。的确有些公司会有这种一起联机玩游戏或者喝酒的文化，不过除非你明确清楚对于目标公司，写上会是加分项，否则还是不写为妙。（顺便说一句，据我了解，阿里的朋友特别喜欢喝酒，面试阿里写上这个可能是加分的，但如果你要是遇到阿里里面正好不喝酒的Team或面试官，不要怪我。） 不要使用word格式的简历，使用PDF的格式。我在招iOS程序员时，好多人的简历都是Word格式的，mac下的office那么难用，公司好多人机器上都没有mac office。我真怀疑这些人真是的想投简历么? PDF格式的简历通常能展现出简历的专业性。 不要使用QQ号开头的QQ邮箱，例如 12345@qq.com ，邮箱的事情我之前简单说过，有些人很在乎这个，有些人觉得无所谓，我个人对用数字开头的QQ邮箱的求职者不会有加分，但是对使用gmail邮箱的求职者有加分。因为这涉及到个人的工作效率，使用gmail的人通常会使用邮件组，过滤器，IMAP协议，标签，这些都有助于提高工作效率。如果你非要使用QQ邮箱，也应该申请一个有意义的邮箱名，例如 tangqiao@qq.com 。相关的讨论可以参见知乎上的讨论：《用人单位拒绝聘用使用 QQ 邮箱发应聘邮件的求职者，这一行为是否合理？》 不要写参加过某某培训公司的iOS培训，特别是那种一、两个月的速成培训。这对于我和身边很多面试官来说，绝对是负分。面试当中，经验是一个考查点，但是学习能力比经验重要多了，如果你是参加培训学习的iOS开发，很可能说明你没有自学能力。这一点似乎很多人都没有搞清楚，大家可以看看 @老赵 在他的个人博客上发表的 《为什么我要反对北大青鸟》。 我在2年前也写过一篇博客《我们必须自学》，详细解释了我的看法。 Posted by 唐巧 Dec 22nd, 2013 summary","tags":[]},{"title":"Picasso使用","date":"2016-12-13T08:11:38.000Z","path":"2016/12/13/Picasso使用/","text":"Introduction http://square.github.io/picasso/ Images add much-needed context and visual flair to Android applications. Picasso allows for hassle-free image loading in your application—often in one line of code! 1Picasso.with(context).load(&quot;http://i.imgur.com/DvpvklR.png&quot;).into(imageView); Many common pitfalls of image loading on Android are handled automatically by Picasso: Handling ImageView recycling and download cancelation in an adapter.Complex image transformations with minimal memory use.Automatic memory and disk caching.Sample application screenshot. Features ADAPTER DOWNLOADS Adapter re-use is automatically detected and the previous download canceled.123456789@Override public void getView(int position, View convertView, ViewGroup parent) &#123; SquaredImageView view = (SquaredImageView) convertView; if (view == null) &#123; view = new SquaredImageView(context); &#125; String url = getItem(position); Picasso.with(context).load(url).into(view);&#125; IMAGE TRANSFORMATIONS Transform images to better fit into layouts and to reduce memory size.12345Picasso.with(context) .load(url) .resize(50, 50) .centerCrop() .into(imageView) You can also specify custom transformations for more advanced effects.1234567891011121314public class CropSquareTransformation implements Transformation &#123; @Override public Bitmap transform(Bitmap source) &#123; int size = Math.min(source.getWidth(), source.getHeight()); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; Bitmap result = Bitmap.createBitmap(source, x, y, size, size); if (result != source) &#123; source.recycle(); &#125; return result; &#125; @Override public String key() &#123; return &quot;square()&quot;; &#125;&#125; Pass an instance of this class to the transform method. PLACE HOLDERS Picasso supports both download and error placeholders as optional features. Picasso.with(context) .load(url) .placeholder(R.drawable.user_placeholder) .error(R.drawable.user_placeholder_error) .into(imageView); A request will be retried three times before the error placeholder is shown. RESOURCE LOADING Resources, assets, files, content providers are all supported as image sources. Picasso.with(context).load(R.drawable.landing_screen).into(imageView1); Picasso.with(context).load(&quot;file:///android_asset/DvpvklR.png&quot;).into(imageView2); Picasso.with(context).load(new File(...)).into(imageView3); DEBUG INDICATORS For development you can enable the display of a colored ribbon which indicates the image source. Call setIndicatorsEnabled(true) on the Picasso instance. Debug ribbon indicators Download ↓ v2.5.2 JAR The source code to the Picasso, its samples, and this website is available on GitHub. MAVEN com.squareup.picasso picasso 2.5.2GRADLE compile ‘com.squareup.picasso:picasso:2.5.2’Contributing","tags":[]},{"title":"Android Studio] *.jar 与 .aar 的生成与.aar导入项目方法","date":"2016-12-13T08:10:43.000Z","path":"2016/12/13/Android-Studio-jar-与-aar-的生成与-aar导入项目方法/","text":"主要讲解Android Studio中生成aar文件以及本地方式使用aar文件的方法。在Android Studio中对一个自己库进行生成操作时将会同时生成.jar与.aar文件。分别存储位置：123*.jar：库/build/intermediates/bundles/debug(release)/classes.jar*.aar：库/build/outputs/aar/libraryname.aar 两者区别：*.jar：只包含了class文件与清单文件，不包含资源文件，如图片等所有res中的文件。 *.aar：包含所有资源，class以及res资源文件全部包含 如果你只是一个简单的类库那么使用生成的.jar文件即可；如果你的是一个UI库，包含一些自己写的控件布局文件以及字体等资源文件那么就只能使用.aar文件。 使用方式： *.jar：拷贝到：libs目录，eclipse直接导入即可，AndroidStudio项目中添加： dependencies { compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) } 重新编译一次项目既可完成加载。 *.aar：有两种方式，分别为本地加载以及网络加载，由于网络加载涉及到发布到mavenCentral托管的问题这里不做讨论；另外eclipse很久没有使用了也不做讨论；在这里给大家说一种本地加载的方式，简单快捷。 这里演示的aar文件为：”genius.aar“ 第一步：拷贝到：libs目录 第二步：build.gradle 配置文件中更改为 repositories { flatDir { dirs &apos;libs&apos; } } dependencies { compile(name:&apos;genius&apos;, ext:&apos;aar&apos;) } 分别添加了”repositories“与更改了”dependencies“，然后重新编译一次项目就可以正常使用了。 这时打开你的项目地址”\buildintermediatesexploded-aar“你会发现下面多了一个文件夹”genius“打开后能看见里边包含了一个”classes.jar“文件与一些资源文件和”R.txt“文件。 \\ 这就是Android Studio自动解析了aar文件后出现的东西。","tags":[]},{"title":"Android Gradle 模块化开发实例 Demo","date":"2016-12-13T08:10:06.000Z","path":"2016/12/13/Android-Gradle-模块化开发实例-Demo/","text":"前言 这两天看到一篇文章很火，详细见：http://stormzhang.com/android/2015/03/01/android-reference-local-aar/我大概看了下，然后搜索了下相关资料，作者说的没有错，我很欣赏这种行为，其实是已经在Google上搜刮过了，然后进行总结写文章。就如作者说的，就算官网上对于aar的描述也是凤毛菱角。简单来讲，jar包中封装的大多是一些方法，但是aar其实就是一个完整的Android App，所以包括了所有的资源文件等，我们可以很好的使用已经封装好的一些风格，包括UI界面显示等。 感谢作者的文章，我也是看了之后想试试看例子，不过网上找了一圈，发现都是在Gradle正式release前的例子，所以就还是自给自足啦。 创建一个aar 既然我们要做，首先先创建一个aar包咯。本次的demo全部是本地化的引用。首先我们new一个新的Module出来。 我们新建了一个Android Library，我们从结构中可以看出和一个Android App的Project没有什么区别。 唯独的区别在于build.gradle，需要定义apply plugin: ‘com.android.library’，告诉studio这是一个library。定义如下： apply plugin: ‘com.android.library’ android { compileSdkVersion 22 buildToolsVersion “22.0.0” defaultConfig { minSdkVersion 10 targetSdkVersion 22 versionCode 1 versionName &quot;1.0&quot; } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; } } } dependencies { compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;com.android.support:appcompat-v7:22.0.0&apos; } 我们现在来修改下我们的主方法，添加一个如下的方法（记得还是修改下主类名）： public static void DisPlayToast(Context context){ Toast.makeText(context,&quot;this is aar toast&quot;,Toast.LENGTH_LONG).show(); } 接着我们就可以来编译啦。进入library，执行gradle assembleDebug，接着我们可以在~/AndroidLibrary2/mylibrary/build/outputs/aar/目录下找到我们编译好的aar文件。是不是很简单 本地加载aar 我们有了aar之后，将这个文件放入我们app工程的libs目录下，这样我们就可以进行调用啦。修改app的build.gradle如下： apply plugin: &apos;com.android.application&apos; android { compileSdkVersion 22 buildToolsVersion &quot;22.0.0&quot; defaultConfig { applicationId &quot;com.example.monkey.androidlibrary2&quot; minSdkVersion 17 targetSdkVersion 22 versionCode 1 versionName &quot;1.0&quot; } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; } } } repositories { flatDir { dirs ‘libs’ } mavenCentral() mavenLocal() } dependencies { compile(name:&apos;mylibrary3-debug&apos;, ext:&apos;aar&apos;) //这里我因为尝试了几次，所以都是数字编号了，大家可以无视 compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;com.android.support:appcompat-v7:22.0.0&apos; } 开始对app进行编译，这样的话工程会自动将这个aar文件解析出来。使用gradle assembleDebug。我们可以看到在/app/build/intermediates/exploded-aar/目录下已经有了我们增加的aar包的文件引用。如下 修改app代码如下123456789101112131415161718192021222324252627282930313233343536373839404142package com.example.monkey.androidlibrary2;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import com.example.monkey.mylibrary.aarActivity;public class MyActivity extends aarActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); DisPlayToast(this); // Toast.makeText(this,&quot;test&quot;,Toast.LENGTH_LONG).show(); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; 其实从maven和jcenter()上下载也是一个逻辑，没有什么太大区别。只不过貌似在Gradle 1.0之前本地引用是有bug的。 代码地址：https://github.com/monkeytest15/Gradle_aar/tree/master/AndroidLibrary2 后续 我发现我sdk更新的不完善，我表示我要回家更新完整之后再做后续的讨论了。","tags":[]},{"title":"Eclipse Java注释模板设置","date":"2016-12-13T08:09:29.000Z","path":"2016/12/13/Eclipse-Java注释模板设置/","text":"设置注释模板的入口： Window-&gt;Preference-&gt;Java-&gt;Code Style-&gt;Code Template 然后展开Comments节点就是所有需设置注释的元素啦。现就每一个元素逐一介绍： 文件(Files)注释标签： /** * @Title: ${file_name} * @Package ${package_name} * @Description: ${todo}(用一句话描述该文件做什么) * @author A18ccms A18ccms_gmail_com * @date ${date} ${time} * @version V1.0 */ 类型(Types)注释标签（类的注释）： /** * @ClassName: ${type_name} * @Description: ${todo}(这里用一句话描述这个类的作用) * @author A18ccms a18ccms_gmail_com * @date ${date} ${time} * * ${tags} */ 字段(Fields)注释标签： /** * @Fields ${field} : ${todo}(用一句话描述这个变量表示什么) */ 构造函数标签： /** * &lt;p&gt;Title: &lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * ${tags} */ 方法(Constructor &amp; Methods)标签： /** * @Title: ${enclosing_method} * @Description: ${todo}(这里用一句话描述这个方法的作用) * @param ${tags} 设定文件 * @return ${return_type} 返回类型 * @throws */ 覆盖方法(Overriding Methods)标签： /* (非 Javadoc) * &lt;p&gt;Title: ${enclosing_method}&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * ${tags} * ${see_to_overridden} */ 代表方法(Delegate Methods)标签： /** * ${tags} * ${see_to_target} */ getter方法标签： /** * @return ${bare_field_name} */ setter方法标签： /** * @param ${param} 要设置的 ${bare_field_name} */","tags":[]},{"title":"Android性能优化之渲染篇","date":"2016-12-13T08:08:50.000Z","path":"2016/12/13/Android性能优化之渲染篇/","text":"Google近期在Udacity上发布了Android性能优化的在线课程，目前有三个篇章，分别从渲染，运算与内存，电量三个方面介绍了如何去优化性能，这些课程是Google之前在Youtube上发布的Android性能优化典范专题课程的细化与补充。 下面是渲染篇章的学习笔记，部分内容和前面的性能优化典范有重合，欢迎大家一起学习交流！ 1)Why Rendering Performance Matters现在有不少App为了达到很华丽的视觉效果，会需要在界面上层叠很多的视图组件，但是这会很容易引起性能问题。如何平衡Design与Performance就很需要智慧了。 2)Defining ‘Jank’大多数手机的屏幕刷新频率是60hz，如果在1000/60=16.67ms内没有办法把这一帧的任务执行完毕，就会发生丢帧的现象。丢帧越多，用户感受到的卡顿情况就越严重。 3)Rendering Pipeline: Common Problems渲染操作通常依赖于两个核心组件：CPU与GPU。CPU负责包括Measure，Layout，Record，Execute的计算操作，GPU负责Rasterization(栅格化)操作。CPU通常存在的问题的原因是存在非必需的视图组件，它不仅仅会带来重复的计算操作，而且还会占用额外的GPU资源。 4)Android UI and the GPU了解Android是如何利用GPU进行画面渲染有助于我们更好的理解性能问题。一个很直接的问题是：activity的画面是如何绘制到屏幕上的？那些复杂的XML布局文件又是如何能够被识别并绘制出来的？ Resterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。 CPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。 然而每次从CPU转移到GPU是一件很麻烦的事情，所幸的是OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作。所以如果你更新了GPU所hold住的纹理内容，那么之前保存的状态就丢失了。 在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。当然随着UI组件的越来越丰富，有了更多演变的形态。例如显示图片的时候，需要先经过CPU的计算加载到内存中，然后传递给GPU进行渲染。文字的显示比较复杂，需要先经过CPU换算成纹理，然后交给GPU进行渲染，返回到CPU绘制单个字符的时候，再重新引用经过GPU渲染的内容。动画则存在一个更加复杂的操作流程。 为了能够使得App流畅，我们需要在每帧16ms以内处理完所有的CPU与GPU的计算，绘制，渲染等等操作。 5)GPU Problem: OverdrawOverdraw(过度绘制)描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的UI结构里面，如果不可见的UI也在做绘制的操作，会导致某些像素区域被绘制了多次。这样就会浪费大量的CPU以及GPU资源。 当设计上追求更华丽的视觉效果的时候，我们就容易陷入采用复杂的多层次重叠视图来实现这种视觉效果的怪圈。这很容易导致大量的性能问题，为了获得最佳的性能，我们必须尽量减少Overdraw的情况发生。 幸运的是，我们可以通过手机设置里面的开发者选项，打开Show GPU Overdraw的选项，观察UI上的Overdraw情况。 蓝色，淡绿，淡红，深红代表了4种不同程度的Overdraw情况，我们的目标就是尽量减少红色Overdraw，看到更多的蓝色区域。 6)Visualize and Fix Overdraw - Quiz &amp; Solution这里举了一个例子，通过XML文件可以看到有好几处非必需的background。通过把XML中非必需的background移除之后，可以显著减少布局的过度绘制。其中一个比较有意思的地方是：针对ListView中的Avatar ImageView的设置，在getView的代码里面，判断是否获取到对应的Bitmap，在获取到Avatar的图像之后，把ImageView的Background设置为Transparent，只有当图像没有获取到的时候才设置对应的Background占位图片，这样可以避免因为给Avatar设置背景图而导致的过度渲染。 总结一下，优化步骤如下： 移除Window默认的Background 移除XML布局文件中非必需的Background 按需显示占位背景图片 7)ClipRect &amp; QuickReject前面有提到过，对不可见的UI组件进行绘制更新会导致Overdraw。例如Nav Drawer从前置可见的Activity滑出之后，如果还继续绘制那些在Nav Drawer里面不可见的UI组件，这就导致了Overdraw。为了解决这个问题，Android系统会通过避免绘制那些完全不可见的组件来尽量减少Overdraw。那些Nav Drawer里面不可见的View就不会被执行浪费资源。 但是不幸的是，对于那些过于复杂的自定义的View(通常重写了onDraw方法)，Android系统无法检测在onDraw里面具体会执行什么操作，系统无法监控并自动优化，也就无法避免Overdraw了。但是我们可以通过canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。 除了clipRect方法之外，我们还可以使用canvas.quickreject()来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。 8)Apply clipRect and quickReject - Quiz &amp; Solution上面的示例图中显示了一个自定义的View，主要效果是呈现多张重叠的卡片。这个View的onDraw方法如下图所示： 打开开发者选项中的显示过度渲染，可以看到我们这个自定义的View部分区域存在着过度绘制。那么是什么原因导致过度绘制的呢？ 9)Fixing Overdraw with Canvas API下面的代码显示了如何通过clipRect来解决自定义View的过度绘制，提高自定义View的绘制性能： 下面是优化过后的效果： 10)Layouts, Invalidations and PerfAndroid需要把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。 在某个View第一次需要被渲染时，Display List会因此被创建，当这个View要显示到屏幕上时，我们会执行GPU的绘制指令来进行渲染。 如果View的Property属性发生了改变（例如移动位置），我们就仅仅需要Execute Display List就够了。 然而如果你修改了View中的某些可见组件的内容，那么之前的DisplayList就无法继续使用了，我们需要重新创建一个DisplayList并重新执行渲染指令更新到屏幕上。 请注意：任何时候View中的绘制内容发生变化时，都会需要重新创建DisplayList，渲染DisplayList，更新到屏幕上等一系列操作。这个流程的表现性能取决于你的View的复杂程度，View的状态变化以及渲染管道的执行性能。举个例子，假设某个Button的大小需要增大到目前的两倍，在增大Button大小之前，需要通过父View重新计算并摆放其他子View的位置。修改View的大小会触发整个HierarcyView的重新计算大小的操作。如果是修改View的位置则会触发HierarchView重新计算其他View的位置。如果布局很复杂，这就会很容易导致严重的性能问题。 11)Hierarchy Viewer: WalkthroughHierarchy Viewer可以很直接的呈现布局的层次关系，视图组件的各种属性。 我们可以通过红，黄，绿三种不同的颜色来区分布局的Measure，Layout，Executive的相对性能表现如何。 12)Nested Hierarchies and Performance提升布局性能的关键点是尽量保持布局层级的扁平化，避免出现重复的嵌套布局。例如下面的例子，有2行显示相同内容的视图，分别用两种不同的写法来实现，他们有着不同的层级。 下图显示了使用2种不同的写法，在Hierarchy Viewer上呈现出来的性能测试差异： 13)Optimizing Your Layout下图举例演示了如何优化ListItem的布局，通过RelativeLayout替代旧方案中的嵌套LinearLayout来优化布局。","tags":[]},{"title":"Android Studio 常用设置","date":"2016-12-13T08:08:03.000Z","path":"2016/12/13/Android-Studio-常用设置/","text":"常用设置： 1.Tab不用4个空格12Code Style-&gt;Java-&gt;Tabs and Indents-&gt;Use tab characterCode Style-&gt;General-&gt;Use tab character （例如：版本控制Diff界面按下Tab） 2.可视化Tab和空格1Settings-&gt;IDE Settings-&gt;Editor-&gt;Appearance-&gt;Show whitespaces 3.显示代码行数1Settings-&gt;IDE Settings-&gt;Editor-&gt;Appearance-&gt;Show line numbers 4.修改代码字体大小1Settings-&gt;IDE Settings-&gt;Editor-&gt;Colors &amp; Fonts -&gt;Font-&gt;Save As-&gt;改个名字后才能改字体大小 5.鼠标悬浮显示doc1Settings-&gt;IDE Settings-&gt;Editor-&gt;Show quick doc on mouse move 6.空行的Tab和空格被自动干掉1Settings-&gt;IDE Settings-&gt;Editor-&gt;Other-&gt;Strip trailing spaces on Save-&gt;None 常用快捷键： 首先改为Eclipse快捷键（然后大部分快捷键都会跟Eclipse一致了）1Settings-&gt;IDE Settings-&gt;Keymap-&gt;Keymaps选择Eclipse 1.像Eclipse那样快速跳出括号1Keymap-&gt;Editor Actions-&gt;Complete Current Statement：默认是Ctrl+Shift+Enter；Shift+Enter则不管现在光标在哪个位置,直接新开一行 2.代码提示列表（Eclipse中的Content Assist，Alt+/）1Keymap-&gt;Main Menu-&gt;Code-&gt;Completion-&gt;Basic：默认是Ctrl+Space 3.错误修正提示列表（Eclipse中的Quick Fix，Ctrl+1）1Keymap-&gt;Other-&gt;Show Intention Action：默认是Alt+Enter 4.快速Overried方法1Keymap-&gt;Main menu-&gt;Code-&gt;Override Methods：需要自己设定 5.Eclipse中的outline1Keymap-&gt;Main Menu-&gt;Navigate-&gt;File Structure：默认是Ctrl+F3 6.版本控制中Diff的Next和Prev12Keymap-&gt;Other-&gt;Move to the next difference：默认是Ctrl+f7Keymap-&gt;Other-&gt;Move to the previous difference：默认是Shift+f7","tags":[]},{"title":"mipmap 目录和drawable 目录有什么区别","date":"2016-12-13T08:07:33.000Z","path":"2016/12/13/mipmap-目录和drawable-目录有什么区别/","text":"使用上没有任何区别,你把它当drawable用就好了。但是用mipmap系统会在缩放上提供一定的性能优化。官方介绍： Mipmapping for drawables Using a mipmap as the source for your bitmap or drawable is a simple way to provide a quality image and various image scales, which can be particularly useful if you expect your image to be scaled during an animation. Android 4.2 (API level 17) added support for mipmaps in the Bitmap class—Android swaps the mip images in your Bitmap when you&apos;ve supplied a mipmap source and have enabled setHasMipMap(). Now in Android 4.3, you can enable mipmaps for a BitmapDrawable object as well, by providing a mipmap asset and setting the android:mipMap attribute in a bitmap resource file or by calling hasMipMap(). 应用场景： If you know that you are going to draw this bitmap at less than 50% of its original size, you may be able to obtain a higher quality by turning this property on. Note that if the renderer respects this hint it might have to allocate extra memory to hold the mipmap levels for this bitmap. 一个应用实例： Nexus 6 Screen The Nexus 6 boasts an impressive 5.96” Quad HD screen display at a resolution of 2560 x 1440 (493 ppi). This translates to ~ 730 x 410 dp (density independent pixels). Check your assets It has a quantized density of 560 dpi, which falls in between the xxhdpi and xxxhdpi primary density buckets. For the Nexus 6, the platform will scale down xxxhdpi assets, but if those aren’t available, then it will scale up xxhdpi assets. Provide at least an xxxhdpi app icon because devices can display large app icons on the launcher. It’s best practice to place your app icons in mipmap- folders (not the drawable- folders) because they are used at resolutions different from the device’s current density. For example, an xxxhdpi app icon can be used on the launcher for an xxhdpi device. res/ mipmap-mdpi/ ic_launcher.png mipmap-hdpi/ ic_launcher.png mipmap-xhdpi/ ic_launcher.png mipmap-xxhdpi/ ic_launcher.png mipmap-xxxhdpi/ ic_launcher.png # App icon used on Nexus 6 device launcher Choosing to add xxxhdpi versions for the rest of your assets will provide a sharper visual experience on the Nexus 6, but does increase apk size, so you should make an appropriate decision for your app. res/ drawable-mdpi/ ic_sunny.png drawable-hdpi/ ic_sunny.png drawable-xhdpi/ ic_sunny.png drawable-xxhdpi/ # Fall back to these if xxxhdpi versions aren’t available ic_sunny.png drawable-xxxhdpi/ # Higher resolution assets for Nexus 6 ic_sunny.png ##总结 ###这个实例总结一下是这样：Nexus 6 有 493 ppi，它刚好在 xxhdpi和xxxhdpi之间，所以显示的时候需要对xxxhdpi的资源进行缩小，如果你用了mipmap-xxxhdpi,那么这里会对sclae有一个优化，性能更好，占用内存更少。所以现在官方推荐使用mipmap： It’sbest practice to place your app icons in mipmap- folders (not the drawable- folders) because they are used at resolutions different from the device’s current density.","tags":[]},{"title":"Android 常用的adb命令","date":"2016-12-13T08:06:26.000Z","path":"2016/12/13/Android-常用的adb命令/","text":"1、安装APK(如果加 -r 参数，保留已设定数据，重新安装filename.apk)12adb install xxx.apk adb install -r xxx.apk 2、卸载APK(如果加 -k 参数，为卸载软件但是保留配置和缓存文件)12adb uninstall xxx.apkadb uninstall -k xxx.apk 3、查看当前所有连接的模拟器设备1adb devices 4、对某一模拟器操作1adb -s 模拟器编号 命令 5、导入文件到模拟器 （该命令也可以实现安装APK，只要把APK导入到”/system/app”或者”/data/app”就OK）1adb push 文件 模拟器路径 6、从模拟器导出文件1adb pull 模拟器文件 本地路径 7、查看模拟器log信息1adb logcat 8、获取管理员权限1adb root 9、进入shell模式1adb shell 10、启动activity (adb shell后面跟的命令主要来自源码\\system\\core\\toolbox目录和源码\\frameworks\\base\\cmds目录)1adb shell am start -n 包名/包名＋类名（-n 类名,-a action,-d date,-m MIME-TYPE,-c category,-e 扩展数据,等） 11、获取设备ID号1adb get-serialno 12、开启adb服务1adb start-server 13、关闭adb服务1adb kill-server 14、访问sqlite312adb shell sqlite3 15、重启设备1adb reboot 16、挂在分区(可使系统分区重新可写)1adb remount 17、发布端口（可以设置任意的端口号，做为主机向模拟器或设备的请求端口）1adb forward tcp:5555 tcp:8000 18、关机命令1adb shell reboot -p 以上就是一些常用的adb命令，如有不懂的或者其它常用的命令，可以留言！","tags":[{"name":"Android Adb","slug":"Android-Adb","permalink":"http://genng.github.io/tags/Android-Adb/"}]},{"title":"Cmd Markdown 简明语法手册","date":"2016-12-12T07:58:19.000Z","path":"2016/12/12/Cmd-Markdown-简明语法手册/","text":"1. 斜体和粗体使用 和 * 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。 2. 分级标题使用 === 表示一级标题，使用 — 表示二级标题。 示例： 1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题 你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 3. 外链接使用 [描述](链接地址) 为文字增加外链接。 示例： 这是去往 本人博客 的链接。 4. 无序列表使用 *，+，- 表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 示例： 野火烧不尽，春风吹又生。 7. 行内代码块使用 `代码` 表示行内代码块。 示例： 让我们聊聊 html。 8. 代码块使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 ![描述](图片链接地址) 插入图像。 示例： Cmd Markdown 高阶语法手册1. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 [TOC] 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 3. 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 4. 注脚使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 5. LaTeX 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 $$ 表示整行公式： $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法。 6. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 7. 流程图示例12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考8. 序列图示例 1123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 212345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考9. 表格支持示例： 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 10. 定义型列表名词 1: 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 11. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 12. 内嵌图标本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 [^footnote]: 这是一个 注脚 的 文本。 [^footnote2]: 这是另一个 注脚 的 文本。","tags":[]},{"title":"hello blog","date":"2016-12-12T07:51:08.000Z","path":"2016/12/12/hello-blog/","text":"你好，欢迎来到我的blog！","tags":[]},{"title":"Hello World","date":"2016-12-12T07:19:14.280Z","path":"2016/12/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]